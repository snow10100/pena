from lg_pentest.pentest_agent.utils.model import _get_model
from lg_pentest.pentest_agent.utils.state import PentestState
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage
from langchain_core.pydantic_v1 import BaseModel, Field
from typing_extensions import Annotated, TypedDict, List, Literal, Optional 

class Results(TypedDict):
    """The results that the pentester needs to work"""
    message: Annotated[str, ..., "Pentester thought process"]
    phase: Annotated[str, ..., "Current phase of pentesting, such as scanning or exploitation"]
    tasks: Annotated[List[dict], ..., "Tasks to perform to complete the current phase"]
    results: Annotated[List[str], ..., "Summary of results"]
    tool_use: Annotated[bool, ..., "Indicates if tools are still needed to complete a task"]
    software: Annotated[List[str], ..., "program names that will be used to perform the tasks"]
    command: Annotated[str, ..., "possible command that will be run"]

# class Results(BaseModel):
#     """The results that the pentester needs to work"""
#     message: str = Field(description="Pentester though process")
#     phase: str = Field(description="Current phase of pentesting, such as scanning or exploitation")
#     tasks: List[dict] = Field(description="Task to perform to be done with the current phase")
#     results: List[str] = Field(description="Summary of results")
#     tool_use: bool = Field(description="If we still need to call tools to perform finish a task")
#     software: List[str] = Field(description="program names that we will use to do the tasks")

    

system_prompt = SystemMessage("""
You are a pentester working with a team of AI agents, you will receive tasks from 
your supervisor, and you will have to use tools by calling a tool agent to 
use the software instead of you. Once everything is done, you pass your results
to the evaluator. Don't complicate things, if a simple command works then use it. 
""")

def _swap_messages(messages):
    new_messages = []
    for m in messages:
        if m['role'] == 'assistant':
            new_messages.append({"role": "user", "content": m['content']})
        else:
            new_messages.append({"role": "assistant", "content": m['content']})
    return new_messages

def pentester(state: PentestState) -> PentestState:
    # print(state)
    tasks = f"""
    Do the following tasks:

    {state['pentest_tasks']}
    """
    # print(f'{tasks = }')
    if state['tool_results']: # remove later, for debugging
        return {'current_step': 'evaluator'}
    # messages = [system_prompt, HumanMessage(content=tasks)] 
    messages = [system_prompt] + [{'role': 'user', 'content': tasks}] +_swap_messages(state['messages'])
    model = _get_model().with_structured_output(Results)
    response = model.invoke(messages)
    print(f'pentester:\n{response = }')
    if response['tool_use']:
        return {
                'messages': [{'role': 'assistant',
                              'content': response['message'],
                              'tool_calls': response['software']}], 
                'current_step': 'pentester',
                # 'tool_name': response['software'][0],
                'tasks': response['tasks'][0],
                # "command": "nmap -sV -sC -p- -oN metasploitable2_scan.txt 192.168.100.231",
                "command": response['command'],
                }
    return {'current_step': 'evaluator'}
