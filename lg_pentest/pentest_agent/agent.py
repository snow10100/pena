from typing import Annotated, TypedDict, Literal

from langgraph.graph import StateGraph, END
from langchain_core.messages import HumanMessage, AIMessage

import operator
# from my_agent.utils.nodes import call_model, should_continue, tool_node
# from my_agent.utils.state import AgentState


# Define the config
class GraphConfig(TypedDict):
    model_name: Literal["anthropic", "openai"]


# Define a new graph
# workflow = StateGraph(AgentState, config_schema=GraphConfig)

# Define the two nodes we will cycle between
# workflow.add_node("agent", call_model)
# workflow.add_node("action", tool_node)

# Set the entrypoint as `agent`
# This means that this node is the first one called
# workflow.set_entry_point("agent")

# # We now add a conditional edge
# workflow.add_conditional_edges(
#     # First, we define the start node. We use `agent`.
#     # This means these are the edges taken after the `agent` node is called.
#     "agent",
#     # Next, we pass in the function that will determine which node is called next.
#     should_continue,
#     # Finally we pass in a mapping.
#     # The keys are strings, and the values are other nodes.
#     # END is a special node marking that the graph should finish.
#     # What will happen is we will call `should_continue`, and then the output of that
#     # will be matched against the keys in this mapping.
#     # Based on which one it matches, that node will then be called.
#     {
#         # If `tools`, then we call the tool node.
#         "continue": "action",
#         # Otherwise we finish.
#         "end": END,
#     },
# )

# We now add a normal edge from `tools` to `agent`.
# This means that after `tools` is called, `agent` node is called next.
# workflow.add_edge("action", "agent")

# Finally, we compile it!
# This compiles it into a LangChain Runnable,
# meaning you can use it as you would any other runnable
# graph = workflow.compile()



# Define the state structure
class PentestState(TypedDict):
    messages: Annotated[list, operator.add]
    current_step: str
    pentest_results: dict
    evaluation: str
    report: str

# Define node functions
def supervisor(state: PentestState) -> PentestState:
    # Logic for supervisor node
    if state['current_step'] == 'start':
        return {'messages': [HumanMessage(content="Begin pentesting process")], 'current_step': 'pentester'}
    elif state['current_step'] == 'evaluated':
        return {'messages': [HumanMessage(content="Generate report")], 'current_step': 'recorder'}
    else:
        return {'current_step': END}

def pentester(state: PentestState) -> PentestState:
    # Logic for pentester node
    return {'messages': [AIMessage(content="Performing pentest")], 'current_step': 'pentester'}

def tools(state: PentestState) -> PentestState:
    # Logic for tools node
    return {'pentest_results': {'vulnerability': 'SQL Injection found'}, 'current_step': 'tools'}

def evaluator(state: PentestState) -> PentestState:
    # Logic for evaluator node
    return {'evaluation': 'Critical vulnerability detected', 'current_step': 'evaluated'}

def recorder(state: PentestState) -> PentestState:
    # Logic for recorder node
    return {'report': 'Pentest Report: Critical SQL Injection vulnerability found', 'current_step': 'end'}

def route_supervisor(state: PentestState) -> Literal['pentester', 'evaluator', 'recorder', '__end__']:
    return state['current_step']

def route_pentester(state: PentestState) -> Literal['tools', 'evaluator']:
    return 'tools' if state['current_step'] == 'pentester' else 'evaluator' 


# Create the graph
workflow = StateGraph(PentestState, config_schema=StateGraph)

# Add nodes
workflow.add_node('supervisor', supervisor)
workflow.add_node('pentester', pentester)
workflow.add_node('tools', tools)
workflow.add_node('evaluator', evaluator)
workflow.add_node('recorder', recorder)

# Add edges
workflow.set_entry_point('supervisor')
workflow.add_conditional_edges('supervisor', route_supervisor)
workflow.add_conditional_edges('pentester', route_pentester)
workflow.add_edge('tools', 'pentester')
workflow.add_edge('evaluator', 'supervisor')
workflow.add_edge('recorder', 'supervisor')

# Compile the graph
pentest_graph = workflow.compile()